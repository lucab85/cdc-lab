# M2V2 – Schema Evolution and Compatibility

> **Pre-requisite:** Make sure the stack is running:
> ```bash
> docker compose up -d
> ```

---

## Step 1 – Review the initial schema (v1)

1. **View the initial customer schema:**

```bash
cat schemas/customer-v1.avsc | jq .
```

You should see:
```json
{
  "type": "record",
  "name": "Customer",
  "fields": [
    {"name": "customer_id", "type": "int"},
    {"name": "email", "type": "string"},
    {"name": "country", "type": "string"}
  ]
}
```

Say:
> "This is our baseline schema. All three fields are required—no defaults, no nulls."

---

## Step 2 – Register the initial schema in Schema Registry

1. **Register v1 schema:**

```bash
curl -s -X POST \
  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
  --data "{\"schema\": $(cat schemas/customer-v1.avsc | jq -c . | jq -Rs .)}" \
  http://localhost:8081/subjects/customer-updates-value/versions | jq .
```

2. **Verify it was registered:**

```bash
curl -s http://localhost:8081/subjects/customer-updates-value/versions | jq .
```

You should see `[1]` indicating version 1 exists.

Say:
> "We've registered our first schema version. Schema Registry now tracks this as the baseline for compatibility checks."

---

## Step 3 – Check the current compatibility setting

1. **Get subject-level compatibility:**

```bash
curl -s http://localhost:8081/config/customer-updates-value | jq .
```

2. **If not set, check global default:**

```bash
curl -s http://localhost:8081/config | jq .
```

The default is usually `BACKWARD`.

3. **Compatibility modes explained:**

| Mode | Rule |
|------|------|
| `BACKWARD` | New schema can read old data |
| `FORWARD` | Old schema can read new data |
| `FULL` | Both backward and forward compatible |
| `BACKWARD_TRANSITIVE` | Compatible with ALL previous versions |
| `NONE` | No compatibility checks |

Say:
> "BACKWARD compatibility means new consumers can read old messages. This is the safest default for schema evolution."

---

## Step 4 – Try to register a BREAKING schema change

1. **View the breaking schema:**

```bash
cat schemas/customer-v2-breaking.avsc | jq .
```

Notice: `email` was renamed to `primary_email` — this breaks backward compatibility!

2. **Attempt to register it:**

```bash
curl -s -X POST \
  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
  --data "{\"schema\": $(cat schemas/customer-v2-breaking.avsc | jq -c . | jq -Rs .)}" \
  http://localhost:8081/subjects/customer-updates-value/versions | jq .
```

3. **Expected error:**

```json
{
  "error_code": 409,
  "message": "Schema being registered is incompatible with an earlier schema..."
}
```

Say:
> "Schema Registry rejected this change! Renaming a required field breaks backward compatibility—old consumers wouldn't know how to read messages with the new field name."

---

## Step 5 – Set stricter compatibility (BACKWARD_TRANSITIVE)

1. **Set compatibility to BACKWARD_TRANSITIVE:**

```bash
curl -s -X PUT \
  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
  --data '{"compatibility": "BACKWARD_TRANSITIVE"}' \
  http://localhost:8081/config/customer-updates-value | jq .
```

2. **Verify the setting:**

```bash
curl -s http://localhost:8081/config/customer-updates-value | jq .
```

Say:
> "BACKWARD_TRANSITIVE requires compatibility with ALL previous versions, not just the latest. This is stricter and safer for long-lived topics."

---

## Step 6 – Register a COMPATIBLE schema change

1. **View the compatible schema:**

```bash
cat schemas/customer-v2-fixed.avsc | jq .
```

Notice the differences:
- `email` is **kept** (preserves backward compatibility)
- `primary_email` is **added** as optional with default `null`
- `country` has a **default** value

2. **Register the compatible schema:**

```bash
curl -s -X POST \
  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
  --data "{\"schema\": $(cat schemas/customer-v2-fixed.avsc | jq -c . | jq -Rs .)}" \
  http://localhost:8081/subjects/customer-updates-value/versions | jq .
```

3. **Expected success:**

```json
{
  "id": 2
}
```

Say:
> "This time it succeeded! We added new fields as optional with defaults, and kept the existing fields. This is the 'roll-forward' pattern for safe schema evolution."

---

## Step 7 – List all schema versions

1. **List versions for the subject:**

```bash
curl -s http://localhost:8081/subjects/customer-updates-value/versions | jq .
```

You should see `[1, 2]`.

2. **Compare the two versions:**

```bash
# Version 1
curl -s http://localhost:8081/subjects/customer-updates-value/versions/1 | jq '.schema | fromjson'

# Version 2
curl -s http://localhost:8081/subjects/customer-updates-value/versions/2 | jq '.schema | fromjson'
```

Say:
> "Schema Registry keeps a complete history. You can always see what changed between versions and roll back if needed."

---

## Step 8 – Test compatibility before registering

1. **Test a schema against existing versions:**

```bash
curl -s -X POST \
  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
  --data "{\"schema\": $(cat schemas/customer-v2-breaking.avsc | jq -c . | jq -Rs .)}" \
  http://localhost:8081/compatibility/subjects/customer-updates-value/versions/latest | jq .
```

2. **Expected result for breaking schema:**

```json
{
  "is_compatible": false
}
```

3. **Test the compatible schema:**

```bash
curl -s -X POST \
  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
  --data "{\"schema\": $(cat schemas/customer-v2-fixed.avsc | jq -c . | jq -Rs .)}" \
  http://localhost:8081/compatibility/subjects/customer-updates-value/versions/latest | jq .
```

4. **Expected result:**

```json
{
  "is_compatible": true
}
```

Say:
> "You can test compatibility BEFORE registering. This is useful in CI pipelines to catch breaking changes early."

---

## Step 9 – Use the evolved schema in streaming SQL

1. **Open the Flink SQL client:**

```bash
docker compose exec flink-jobmanager ./bin/sql-client.sh
```

2. **Create a source table over the CDC topic:**

```sql
CREATE TABLE customers_raw (
  customer_id  INT,
  first_name   STRING,
  last_name    STRING,
  email        STRING,
  country      STRING,
  primary_email STRING,
  PRIMARY KEY (customer_id) NOT ENFORCED
) WITH (
  'connector' = 'kafka',
  'topic' = 'appdb.public.customers',
  'properties.bootstrap.servers' = 'kafka:9092',
  'properties.group.id' = 'flink-customers-schema-demo',
  'format' = 'debezium-json',
  'scan.startup.mode' = 'earliest-offset'
);
```

3. **Query with COALESCE to handle both old and new fields:**

```sql
SELECT
  customer_id,
  COALESCE(primary_email, email) AS effective_email,
  country
FROM customers_raw;
```

Press `Q` to exit the result view.

4. **Exit Flink SQL:**

```sql
EXIT;
```

Say:
> "While migrating, use COALESCE to prefer new fields but fall back to old ones. This lets you gradually transition consumers without breaking anything."

---

## Key Takeaways

| Pattern | Description |
|---------|-------------|
| **Breaking change** | Renaming/removing required fields — REJECTED |
| **Compatible change** | Adding optional fields with defaults — ACCEPTED |
| **Roll-forward** | Keep old fields, add new ones, migrate gradually |
| **Roll-back** | Revert to last known good schema if needed |

---

## Compatibility Quick Reference

| Change Type | BACKWARD Compatible? |
|-------------|---------------------|
| Add optional field with default | ✅ Yes |
| Add required field | ❌ No |
| Remove optional field | ✅ Yes |
| Remove required field | ❌ No |
| Rename field | ❌ No |
| Change field type | ❌ Usually no |

---

## Quick Reset

To reset and replay the demo:

```bash
# Delete the subject (all versions)
curl -X DELETE http://localhost:8081/subjects/customer-updates-value

# Permanently delete (hard delete)
curl -X DELETE http://localhost:8081/subjects/customer-updates-value?permanent=true

# Re-register v1
curl -s -X POST \
  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
  --data "{\"schema\": $(cat schemas/customer-v1.avsc | jq -c . | jq -Rs .)}" \
  http://localhost:8081/subjects/customer-updates-value/versions
```

To reset the entire stack:

```bash
docker compose down -v
docker compose up -d
```
