Step 1 – Inspect the current schema and compatibility
1.	In your browser, open the Schema Registry UI or use the API.
2.	List subjects:
3.	curl http://localhost:8081/subjects
4.	Pick a value subject, for example:
o	customer-updates-value
5.	Get the latest schema:
6.	curl http://localhost:8081/subjects/customer-updates-value/versions/latest
Note the structure—maybe:
{
  "type": "record",
  "name": "Customer",
  "fields": [
    {"name": "customer_id", "type": "int"},
    {"name": "email",       "type": "string"},
    {"name": "country",     "type": "string"}
  ]
}
7.	Check its compatibility setting:
8.	curl http://localhost:8081/config/customer-updates-value
If nothing is set, also check the global config; we’ll assume BACKWARD by default.
Step 2 – Create a breaking schema change
1.	In your editor, create customer-v2-breaking.avsc:
	{
	  "type": "record",
	  "name": "Customer",
	  "fields": [
	    {"name": "customer_id", "type": "int"},
	    {"name": "primary_email", "type": "string"},
	    {"name": "country", "type": "string"}
	  ]
	}
Here we’ve renamed email to primary_email and kept it required—this is breaking under backward compatibility.
11.	Try to register this new version:
	curl -X POST \
	  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
	  --data '{"schema": "'"$(cat customer-v2-breaking.avsc | tr -d '\n')"'"}' \
	  http://localhost:8081/subjects/customer-updates-value/versions
16.	Schema Registry responds with an error similar to:
{
	  "error_code": 409,
	  "message": "Schema being registered is incompatible with earlier schema"
}
This is exactly what we want: Registry is protecting existing consumers from a breaking change.
Step 3 – Strengthen compatibility (BACKWARD_TRANSITIVE)
1.	Now we’ll make the rules clearer and stronger. Set the subject’s compatibility to BACKWARD_TRANSITIVE:
	curl -X PUT \
	  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
	  --data '{"compatibility": "BACKWARD_TRANSITIVE"}' \
	  http://localhost:8081/config/customer-updates-value
6.	With BACKWARD_TRANSITIVE, every new schema must be backward compatible with all previous versions, not just the latest. This encourages additive, safe evolution over time.
7.	Re-run the same registration command with the breaking schema. It still fails—and that’s correct. Compatibility rules are doing their job.
Step 4 – Fix the schema with additive changes and defaults
1.	Instead of renaming the field directly, we’ll add new fields additively and use defaults. Create customer-v2-fixed.avsc:
{
	  "type": "record",
	  "name": "Customer",
	  "fields": [
	    {"name": "customer_id", "type": "int"},
	    {"name": "email",       "type": "string"},
	    {
	      "name": "primary_email",
	      "type": ["null", "string"],
      "default": null
	    },
	    {
	      "name": "country",
	      "type": "string",
	      "default": "UNKNOWN"
	    }
	  ]
}
Here’s what we’ve done:
o	Kept existing email so old consumers still work.
o	Added primary_email as nullable with a default of null.
o	Added a default for country to make it safe for older producers.
20.	Register this schema:
	curl -X POST \
	  -H "Content-Type: application/vnd.schemaregistry.v1+json" \
	  --data '{"schema": "'"$(cat customer-v2-fixed.avsc | tr -d '\n')"'"}' \
	  http://localhost:8081/subjects/customer-updates-value/versions
25.	This time the call should succeed and return a new id and version number. We’ve rolled forward with a compatible schema.
Step 5 – Confirm downstream resumes without data loss
1.	Restart or resume the producer (for example, Debezium connector or a test app) that writes to the customer-updates topic.
2.	In a consumer (Flink SQL, ksqlDB, or a simple Avro consumer), read from the topic and confirm:
o	Old messages still decode properly using the old schema.
o	New messages include primary_email, which new consumers can start using.
o	No messages are dropped; offsets continue from where they left off.
3.	Optionally, in your streaming SQL engine, add logic that gradually prefers primary_email but still falls back to email:
	SELECT
	  customer_id,
	  COALESCE(primary_email, email) AS effective_email,
	  country
	FROM customer_stream;
This is the practical pattern: use Schema Registry to enforce compatibility and SQL to manage the rollout of new fields.
Step 6 – Rollback vs. roll-forward: when to choose what
1.	Rollback is appropriate when:
o	A bad schema has already been published and is completely wrong.
o	No consumers can handle it safely.
o	It’s easier to revert to the last known good schema and republish later with a correct design.
2.	Roll-forward is appropriate when:
o	You can add fields and defaults to make the new design compatible.
o	Some consumers are ready for the new fields, others are not.
o	You want to keep moving while preserving old behavior.
3.	In our demo, we chose roll-forward by adding primary_email and defaults, instead of forcing every consumer to switch immediately.
