Step 1 – Open the Debezium connector JSON
1.	In your editor, open postgres-cdc-connector.json.
2.	At the top you’ll see standard Kafka Connect fields:
	{
	  "name": "postgres-cdc",
	  "config": {
	    "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
	    "tasks.max": "1",
	    "database.hostname": "postgres",
	    "database.port": "5432",
	    "database.user": "cdc_user",
	    "database.dbname": "appdb"
	  }
	}
Step 2 – Review snapshot vs. tail settings
1.	Scroll to the snapshot config:
	"snapshot.mode": "initial",
	"slot.name": "cdc_slot"
4.	Explain: snapshot.mode="initial" means we take a consistent snapshot, then switch to tailing the WAL for new changes. For CI, you might prefer initial_only so each run resets cleanly.
Step 3 – Add filters and key handling
1.	Locate the filter section and include only the schemas/tables you need:
	"table.include.list": "public.customers,public.orders"
3.	Debezium uses the table’s primary key as the Kafka record key by default. No extra config is needed, but we do wire the converters:
	"key.converter": "io.confluent.connect.avro.AvroConverter",
	"value.converter": "io.confluent.connect.avro.AvroConverter",
	"key.converter.schema.registry.url": "http://schema-registry:8081",
	"value.converter.schema.registry.url": "http://schema-registry:8081"
8.	This means keys and values are Avro-encoded and registered in Schema Registry.
Step 4 – Post the connector and inspect topics
1.	In a terminal, register the connector:
	curl -X POST \
	  -H "Content-Type: application/json" \
	  --data @postgres-cdc-connector.json \
	  http://connect:8083/connectors
6.	Insert a test row into public.customers.
7.	In a Kafka UI or CLI, inspect the appdb.public.customers topic:
o	The key is the customer_id.
o	The value is a Debezium envelope with before, after, and metadata.
Step 5 – Check Schema Registry subjects and versions
1.	Open Schema Registry’s UI or call the API:
	curl http://schema-registry:8081/subjects
3.	You should see subjects like:
o	appdb.public.customers-key
o	appdb.public.customers-value
This is the default TopicNameStrategy: <topic>-key and <topic>-value.
4.	Click appdb.public.customers-value and note version 1. Any schema change will create version 2, 3, and so on.
Step 6 – See compatibility in action
1.	In the Schema Registry UI, set the compatibility for this subject to BACKWARD.
2.	Now, modify the database to add a nullable column (additive change) and restart the connector or trigger a snapshot. Version 2 should register successfully.
3.	Try a breaking change—like renaming a required field—and watch Schema Registry reject the new schema. The producer (our connector) can’t publish it, protecting consumers automatically.
Step 7 – Practical tips for local and CI
1.	For local dev:
o	Use snapshot.mode="initial" for fast feedback.
o	Keep table.include.list tight to avoid noisy topics.
2.	For CI pipelines:
o	Use environment-specific slot.name and connector names.
o	Consider snapshot.mode="initial_only" so each run is deterministic.
o	Pin the same Schema Registry URL and subject naming strategy across environments to avoid surprises.
